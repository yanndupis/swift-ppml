/*
THIS FILE WAS AUTOGENERATED! DO NOT EDIT!
file to edit: encrypted_tensor.ipynb

*/




// Source: The original python implementation can be found here:
// https://github.com/mortendahl/privateml/blob/master/image-analysis/pond/tensor.py

import TensorFlow

let SCALING_BASE = 3
let PRECISION_INTEGRAL   = 7
let PRECISION_FRACTIONAL = 8
let MATMUL_THRESHOLD = 256
let TRUNCATION_GAP = 20

let SCALING_FACTOR = pow(Float(SCALING_BASE), Float(PRECISION_FRACTIONAL))
let TOTAL_PRECISION = PRECISION_INTEGRAL + PRECISION_FRACTIONAL
let BOUND_SINGLE_PRECISION = Int64(pow(Float(SCALING_BASE), Float(TOTAL_PRECISION)))
let NATIVE_MIN = Int64.min
let NATIVE_MAX = Int64.max


extension TensorShape {
  func countElements() -> Int{
    var nb_el = 1
    for i in 0 ..< self.count{
      nb_el = nb_el * self[i]
    }
    return nb_el
  }
}

func _encode(rationals: Tensor<Float>) -> Tensor<Int64>{
    let scaled = rationals * SCALING_FACTOR 
    let integer = Tensor<Int64>(scaled)
    return integer
}

func _decode(field_element: Tensor<Int64>) -> Tensor<Float>{
    let bound = BOUND_SINGLE_PRECISION
    let scaled = (field_element + bound) - bound
    let scaled_rationals = Tensor<Float>(scaled)
    return scaled_rationals / Float(SCALING_FACTOR)
}

// NOTE Should be able to use Tensor(randomUniform instead)
func makeRandomList(_ n: Int, min: Int64 = NATIVE_MIN, max: Int64 = NATIVE_MAX) -> [Int64] {
    return (0..<n).map { _ in Int64.random(in: min..<max) }
}

func _share(x: Tensor<Int64>) -> (Tensor<Int64>, Tensor<Int64>){
    let share0 = Tensor<Int64>(makeRandomList(x.shape.countElements())).reshaped(to: x.shape)
    let share1 = x - share0
    return (share0, share1)
}

func reconstruct(share0: Tensor<Int64>, share1: Tensor<Int64>) -> Tensor<Int64>{
  let rec = share0 + share1
  return rec
}


// PublicTensor

public struct PublicTensor {
  let elements: Tensor<Int64>

  init(elements: Tensor<Int64>){
    self.elements = elements
  }

  public static func from_values(values: Tensor<Float>) -> PublicTensor{
    let enc_val = _encode(rationals: values)

    return PublicTensor(elements: enc_val)
  }

  public func unwrap() -> Tensor<Int64>{
    return self.elements
  }

  public func reveal() -> PublicTensor{
    return self
  }

  public func decode() -> Tensor<Float>{
    return _decode(field_element: self.elements)
  }
    
  public func truncate() -> PublicTensor {
    let positive_numbers = Tensor<Int64>(_Raw.lessEqual(self.elements, Tensor<Int64>([0])))
    var elements = self.elements
    elements = (2 * positive_numbers - 1) * elements
    elements = _Raw.floorDiv(elements, Tensor<Int64>([Int64(SCALING_FACTOR)]))
    elements = (2 * positive_numbers - 1) * elements

    return PublicTensor(elements: elements)
   }
 }


func add(x: PublicTensor, y: PublicTensor) -> PublicTensor{
    let elements = x.elements + y.elements
    return PublicTensor(elements: elements)
}
    
func mul(x: PublicTensor, y: PublicTensor) -> PublicTensor{
    let elements = _Raw.mul(x.elements, y.elements)
    return PublicTensor(elements: elements).truncate()
}


public func matmul(x: PublicTensor, y: PublicTensor) -> PublicTensor{
    let elements = _Raw.matMul(x.elements, y.elements)
    return PublicTensor(elements: elements).truncate()
}


// PublicFieldTensor

public struct PublicFieldTensor {
  let elements: Tensor<Int64>

  init(elements: Tensor<Int64>){
    self.elements = elements
  }

  public static func from_values(values: Tensor<Int64>) -> PublicFieldTensor{
    let enc_val = values
    return PublicFieldTensor(elements: enc_val)
  }

  public func reveal() -> PublicFieldTensor {
    return self
  }
}

public func add(x: PublicFieldTensor, y: PublicFieldTensor) -> PublicFieldTensor{
    let elements = x.elements + y.elements
    return PublicFieldTensor(elements: elements)
  }

public func add(x: PublicFieldTensor, y: PrivateFieldTensor) -> PrivateFieldTensor{
    let share0 = x.elements + y.share0
    let share1 = y.share1
    return PrivateFieldTensor(share0: share0, share1: share1)
}

func matmul(x: PublicFieldTensor, y: PublicFieldTensor) -> PublicFieldTensor{
    let elements = Raw.matMul(x.elements, y.elements)
    return PublicFieldTensor(elements: elements)
}

func matmul(x: PublicFieldTensor, y: PrivateFieldTensor) -> PrivateFieldTensor{
    let share0 = Raw.matMul(x.elements, y.share0)
    let share1 = Raw.matMul(x.elements, y.share1)
    return PrivateFieldTensor(share0: share0, share1: share1)
}


// PrivateFielTensor 

public struct PrivateFieldTensor {
  let share0: Tensor<Int64>
  let share1: Tensor<Int64>

  init(share0: Tensor<Int64>, share1: Tensor<Int64>){
    self.share0 = share0
    self.share1 = share1
  }

  public static func from_values(values: Tensor<Int64>) -> PrivateFieldTensor{
    let x_shared = _share(x: values)
    return PrivateFieldTensor(share0: x_shared.0, share1: x_shared.1)
  }

  public func reveal() -> PublicFieldTensor{
  let x_rec = reconstruct(share0: self.share0, share1: self.share1)
    return PublicFieldTensor.from_values(values: x_rec)
  }
}

public func add(x: PrivateFieldTensor, y: PrivateFieldTensor) -> PrivateFieldTensor{
    let share0 = x.share0 + y.share0
    let share1 = x.share1 + y.share1
    return PrivateFieldTensor(share0: share0, share1: share1)
}
    
 public func add(x: PrivateFieldTensor, y: PublicFieldTensor) -> PrivateFieldTensor{
    let share0 = x.share0 + y.elements
    let share1 = x.share1
    return PrivateFieldTensor(share0: share0, share1: share1)
  }

public func matmul(x: PrivateFieldTensor, y: PublicFieldTensor) -> PrivateFieldTensor{
    let share0 = Raw.matMul(x.share0, y.elements) 
    let share1 = Raw.matMul(x.share1, y.elements)
    return PrivateFieldTensor(share0: share0, share1: share1)
    }


public struct PrivateTensor {
  let share0: Tensor<Int64>
  let share1: Tensor<Int64>

  var shape: TensorShape {
        return share0.shape
    }

  init(share0: Tensor<Int64>, share1: Tensor<Int64>){
    self.share0 = share0
    self.share1 = share1
  }

  public static func from_values(values: Tensor<Float>) -> PrivateTensor{
    let x_shared = _share(x: _encode(rationals: values))
    return PrivateTensor(share0: x_shared.0, share1: x_shared.1)
  }

  public func reveal() -> PublicTensor{
    let x_rec = _decode(field_element: reconstruct(share0: self.share0, share1: self.share1))
    return PublicTensor.from_values(values: x_rec)
  }

  public func truncate() -> PrivateTensor {
    let share0 = _Raw.floorDiv(self.share0, Tensor<Int64>([Int64(SCALING_FACTOR)]))
    let share1 =  _Raw.floorDiv(self.share1, Tensor<Int64>([Int64(SCALING_FACTOR)]))
    return PrivateTensor(share0: share0, share1: share1)
   }
}

func generate_dot_triple(m: Int, n: Int, o: Int) -> (PrivateFieldTensor, 
                                                     PrivateFieldTensor, 
                                                     PrivateFieldTensor){

    let a = Tensor<Int64>(makeRandomList(m*n)).reshaped(to: [m, n])
    let b = Tensor<Int64>(makeRandomList(n*o)).reshaped(to: [n, o])
    let ab = Raw.matMul(a, b)
    return (PrivateFieldTensor.from_values(values: Tensor<Int64>(a)), 
            PrivateFieldTensor.from_values(values: Tensor<Int64>(b)), 
            PrivateFieldTensor.from_values(values: Tensor<Int64>(ab)))
}

public func add(x: PrivateTensor, y: PublicTensor) -> PrivateTensor{
    let share0 =  x.share0 + y.elements
    let share1 = x.share1
    return PrivateTensor(share0: share0, share1: share1)
  }
    
public func add(x: PrivateTensor, y: PrivateTensor) -> PrivateTensor{
    let share0 = x.share0 + y.share0
    let share1 = x.share1 + y.share1
    return PrivateTensor(share0: share0, share1: share1)
}

public func + (x: PrivateTensor, y: PrivateTensor) -> PrivateTensor{
    return add(x: x, y: y)
}

public func sub(x: PrivateTensor, y: PublicTensor) -> PrivateTensor{
    let share0 = x.share0 - y.elements
    let share1 = x.share1
    return PrivateTensor(share0: share0, share1: share1)
}

public func sub(x: PrivateTensor, y: PrivateTensor) -> PrivateTensor{
    let share0 = x.share0 - y.share0
    let share1 = x.share1 - y.share1
    return PrivateTensor(share0: share0, share1: share1)
}

public func sub(x: PrivateTensor, y: PrivateFieldTensor) -> PrivateFieldTensor{
  let share0 = x.share0 - y.share0
  let share1 = x.share1 - y.share1
  return PrivateFieldTensor(share0: share0, share1: share1)
}


public func matmul(x: PrivateTensor, y: PrivateTensor) -> PrivateTensor{
    let m = x.shape[0]
    let n = x.shape[1]
    let o = y.shape[1]

    let triple = generate_dot_triple(m: m, n: n, o: o)
    let a = triple.0 
    let b = triple.1 
    let ab = triple.2

    let alpha_r = sub(x: x, y: a).reveal()
    let beta_r = sub(x: y, y: b).reveal()
    let z_1 = matmul(x: alpha_r, y: beta_r)
    let z_2 = matmul(x: alpha_r, y: b)
    let z_3 = matmul(x: a, y: beta_r)
    let z = add(x: add(x: add(x: z_1, y: z_2), y: z_3), y: ab)

    return PrivateTensor(share0: z.share0 , share1: z.share1).truncate()
}
